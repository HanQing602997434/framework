
// 服务器架构概述（https://www.gameres.com/855559.html）
/*
    架构的分析模型：
        软件架构的分析从不同层面，包括一下几种：

            1.运行时架构——这种架构关心如何解决运行时效率的问题，通常以程序进程图，数据流程图为表达方式。
            在大多数开发团队的架构设计文档中，都会包含运行时架构，说明这是一种非常重要的设计方面。
            这种架构会显著的影响软件代码的开发效率和部署效率。

            2.逻辑架构——这种架构关心软件代码之间的关系，主要目的是为了提高软件应对需求变更的便利性。
            人们往往会以类图、模块图来表达这种架构。这种架构设计在需要长期运营和重用性高的项目中，
            有着至关重要的作用。因为软件的可扩展性和可重用度基本是由这个方面的设计决定的。

            3.物理架构——关心软件如何部署，以机房、服务器、网络设备为主要描述对象。

            4.数据架构——关心软件设计的数据结构的设计，对于数据分析挖掘，多系统协作有较大的意义。

            5.开发架构——关心软件开发库之间的关系，以及版本管理、开发工具、编译构建的设计，主要为了提高多人协作开发，
            以及复杂软件库引用的开发效率。现在流行的集成构建系统就是一种开发架构的理论。

        游戏服务器架构的要素：
            服务端软件的本质，是一个会长期运行的程序，并且它还要服务于多个不定时，不定地点的网络请求。
            所以这类软件的特点是要非常关注稳定性和性能。这类程序如果需要多个协作来提高承载能力，则还要
            关注部署和扩容的便利性；同时，还需要考虑如何实现某种程度的容灾需求。由于多进程协同工作，也
            带来了开发的复杂度，这也是需要关注的问题。

            功能约束，是架构设计决定性因素。一个万能的架构，必定是无能的架构。一个优秀的架构，则是正好
            把握了对应业务领域的核心功能产生的。游戏领域的功能特征，于服务器端系统来说，非常明显的表现
            为几个功能的需求：

                1.对于游戏数据和玩家数据的存储；
        
                2.对玩家客户端进行数据广播；
            
                3.把一部分游戏逻辑在服务器上运算，便于游戏更新内容，以及防止外挂。

            针对以上需求特征，在服务器端软件开发上，我们往往会关注软件对电脑内存和CPU的使用，以求在特定
            业务代码下，能尽量满足承载量和响应延迟的需求。最基本的做法就是"时空转换"，用各种缓存的方式
            来开发程序，以求在CPU时间和内存空间上取得合适的平衡。在CPU和内存之上，是另外一个约束因素：网卡。
            网络带宽直接限制了服务器的处理能力，所以游戏服务器架构也必定要考虑这个因素。

            对于游戏服务器架构设计来说，最重要的是利用游戏产品的需求约束，从而优化出对此特定功能最合适的
            "时-空"架构。并且最小化对网络带宽的占用。

        核心的三个架构：
            最重要的部分，如果使用CPU、内存、网卡的设计：

                1.内存架构：主要决定服务器如何使用内存，以保证尽量少的内存泄露的可能，以及最大化利用服务器
                端内存来提高承载，降低服务延迟。

                2.调度架构：设计如何使用进程、线程、协程这些对于CPU调度的方案。选择同步、异步等不同的编程
                模型，以提高服务器的稳定性和承载量。同时也要考虑对于开发带来的复杂度问题。现在出现的虚拟化
                技术，如虚拟机、docker、云服务器等，都为调度架构提高了更多的选择。

                3.通信架构：决定使用何种方式通讯。网络通讯包含有传输层的选择，如TCP/UDP；据表达层选择，如
                定义协议；以及应用层的接口设计，如消息队列，事件分发、远程调度。

        游戏服务器模型的进化历程：
            最早的游戏服务器是比较简单的，如UO《网络创世纪》的服务端一张3.5寸软盘就能存下。基本上只是一个
            广播和存储文件的服务器程序。后来由于国内的外挂、盗版流行，各游戏厂商开始以MUD为模型，建立主要
            运行逻辑在服务器端的架构。这种架构不断发展，从而出现了以地图、视野等分布要素设计的分布式游戏服
            务器。而在另外一个领域，休闲游戏，天然的需要集中超高的在线用户，所以全区架构开始出现。现代的游
            戏服务器架构，基本上都希望能结合承载量和扩展性的优点来设计，从而形成更加丰富多样的形态。
    
    分服模型：
        模型描述：
            分服模型是游戏服务器中最典型，也是历史最悠久的模型。其特征是游戏服务器的一个个单独的世界。每个
            服务器的账号是独立的，而且只用同一服务器的账号才能产生线上交互。在早期服务器的承载量达到上线的
            时候，游戏开发者就通过假设更多的服务器来解决。这样后来以服务器的开放、合并形成了一套成熟的运营
            手段。一个技术上的选择最后导致了游戏运营方式的模式，是一个非常有趣的现象。

        调度架构：
            1.单进程游戏服务器
                最简单的游戏服务器只有一个进程，是一个单点。这个进程如果退出，则整个游戏世界消息。在此进程中，
                由于需要处理并发的客户端的数据包，因此产生了多种选择方法：

                同步-动态多线程：每个会话到来就会开辟一个线程进行处理，会话由TCP连接socket决定，逻辑的执行
                使用的阻塞模式，编码直观。但是这个方案也有明显的缺点，就是服务器容易产生大量线程，这对于内存
                占用不好控制，同时线程切换也会造成CPU的性能损失。更重要的是多线程对共享数据的读写需要处理锁
                的问题，这可能让代码变得非常复杂，造成各种死锁的BUG，影响服务器的稳定性。

                同步-多线程池：为了节约线程的建立和释放，建立了一个线程池。每个用户会话建立的时候，向线程池申
                请处理线程的使用。在用户会话结束的时候，线程不退出，而是向线程池“释放”对此线程的使用。线程池
                能很好的控制线程数量，可以防止用户暴涨下对服务器造成的连接冲击，形成一种排队进入的机制。但是
                线程池本身的实现比较复杂，而“申请”、“释放”线程的调用规则需要严格遵守，否则会出现线程泄露，耗
                尽线程池。

                异步-单线程/协程：在游戏行业中，采用Linux的epoll作为网络API，以期得到高性能，是一个常见的选择。
                游戏服务器的进程中最常见的阻塞调用就是网络IO，因此在采用epoll之后，整个服务器进程就可以变得完全
                没有阻塞调用，这样只需要一个线程即可。这彻底解决了多线程的锁问题，而且简化了对于并发编程的难度。
                但是，"所有调用都不阻塞"的约束，并不是那么容易遵守的，比如有些数据库的API就是阻塞的；另外单进程
                单线程只能使用一个CPU，在现在多核多CPU的服务器情况下，不能充分利用CPU资源。异步编程由于是基于
                "回调"的方式，会导致要定义很多回调函数，并且把一个流程里面的逻辑，分别卸载多个不同的回调函数里面，
                对于代码阅读非常不利。——针对这种编程问题，协程能较好的帮忙，所以现在比较流程使用异步+协程的结合。
                不管怎样，异步- 单线程模型由于性能好，无需并发思维，依然能是现在很多团队的首选。

                异步-固定多线程：

            2.多进程游戏服务器
*/